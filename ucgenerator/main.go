package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/aiven/go-api-schemas/pkg/dist"
	"github.com/dave/jennifer/jen"
	"golang.org/x/exp/slices"
	"golang.org/x/tools/imports"
	"gopkg.in/yaml.v3"
)

const (
	destPath         = "./internal/sdkprovider/userconfig/"
	localPrefix      = "github.com/aiven/terraform-provider-aiven"
	importSchema     = "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	importDiff       = "github.com/aiven/terraform-provider-aiven/internal/sdkprovider/userconfig/diff"
	importValidation = "github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	codeGenerated    = "Code generated by user config generator. DO NOT EDIT."
)

func main() {
	var serviceList, integrationList, integrationEndpointList string
	flag.StringVar(&serviceList, "services", "", "Comma separated service list of names to generate for")
	flag.StringVar(&integrationList, "integrations", "", "Comma separated integrations list of names to generate for")
	flag.StringVar(&integrationEndpointList, "integration-endpoints", "", "Comma separated integration endpoints list of names to generate for")
	flag.Parse()

	if serviceList+integrationList+integrationEndpointList == "" {
		log.Fatal("--service or --integrations or --integration-endpoints must be provided")
	}

	if serviceList != "" {
		err := generate("service", dist.ServiceTypes, strings.Split(serviceList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}

	if integrationList != "" {
		err := generate("integration", dist.IntegrationTypes, strings.Split(integrationList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}

	if integrationEndpointList != "" {
		err := generate("integration_endpoint", dist.IntegrationEndpointTypes, strings.Split(integrationEndpointList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}
}

func generate(kind string, data []byte, keys []string) error {
	slices.Sort(keys)
	var root map[string]*object

	err := yaml.Unmarshal(data, &root)
	if err != nil {
		return err
	}

	dirPath := filepath.Join(destPath, kind)
	err = os.MkdirAll(dirPath, os.ModePerm)
	if err != nil {
		return err
	}

	// Fixes imports order
	imports.LocalPrefix = localPrefix

	doneKeys := make([]string, 0, len(keys))
	doneNames := make([]string, 0, len(keys))

	for _, key := range keys {
		o, ok := root[key]
		if !ok {
			return fmt.Errorf("key %q not found in spec", key)
		}

		o.isRoot = true
		o.init(key + "_user_config")
		if o.Description == "" {
			o.Description = toUpperFirst(o.camelName) + " user configurable settings"
		}

		doneKeys = append(doneKeys, key)
		doneNames = append(doneNames, o.camelName)

		f := jen.NewFile(kind)
		f.HeaderComment(codeGenerated)
		f.ImportName(importSchema, "schema")
		f.ImportName(importDiff, "diff")
		f.ImportName(importValidation, "validation")
		genSchema(f, o)

		// Sorts imports
		b, err := imports.Process("", []byte(f.GoString()), nil)
		if err != nil {
			return err
		}

		// Saves file
		err = os.WriteFile(filepath.Join(dirPath, key+".go"), b, 0644)
		if err != nil {
			return err
		}
	}

	cases := make([]jen.Code, 0, len(keys)+1)
	for i, k := range doneKeys {
		cases = append(cases, jen.Case(jen.Lit(k)).Block(
			jen.Return(jen.Id(doneNames[i]).Call()),
		))
	}

	// Panics if unknown kind requested
	cases = append(cases, jen.Default().Block(jen.Panic(jen.Lit("unknown user config type: ").Op("+").Id("kind"))))

	f := jen.NewFile(kind)
	f.HeaderComment(codeGenerated)
	f.ImportName(importSchema, "schema")
	f.Func().Id("GetUserConfig").Params(jen.Id("kind").String()).Op("*").Qual(importSchema, "Schema").Block(
		jen.Switch(jen.Id("kind")).Block(cases...),
	)
	return f.Save(filepath.Join(dirPath, kind+".go"))
}

func genSchema(f *jen.File, o *object) {
	f.Func().Id(o.camelName).Params().Op("*").Qual(importSchema, "Schema").Block(
		jen.Return(jen.Op("&").Qual(importSchema, "Schema").Values(getSchemaValues(o))),
	)
}

func getSchemaValues(o *object) jen.Dict {
	values := make(jen.Dict)

	if d := getDescription(o); d != "" {
		for old, n := range replaceDescriptionSubStrings {
			d = strings.ReplaceAll(d, old, n)
		}
		values[jen.Id("Description")] = jen.Lit(d)
	}

	var t string
	switch o.Type {
	case objectTypeObject, objectTypeArray:
		if o.isSchemaless() {
			// todo: handle schemaless if this happens
			log.Fatalf("schemaless is not implemented: %q", o.jsonName)
		}

		t = "List"
		if o.isArray() && o.ArrayItems.isScalar() {
			// Stores scalars in the set type.
			// Nested sets of objects do not work well in Terraform:
			// - Changing a field shows diff for the whole object,
			//   because hash is calculated for the object, not per field.
			//   So no per-field updates, whole object replacement only.
			//   https://discuss.hashicorp.com/t/provider-schema-typeset-detect-changes/32546
			// - There is a bug that doesn't let you put a set deep inside ResourceData
			//   https://github.com/hashicorp/terraform-plugin-sdk/issues/459
			// - The diff itself is invalid for nested sets (not on the root level).
			//   It just doesn't work as expected in all cases.
			t = "Set"
		}

		if o.MinItems != nil {
			values[jen.Id("MinItems")] = jen.Lit(*o.MinItems)
		}
		if o.MaxItems != nil {
			values[jen.Id("MaxItems")] = jen.Lit(*o.MaxItems)
		}
	case objectTypeBoolean:
		t = "Bool"
	case objectTypeString:
		t = "String"
	case objectTypeInteger:
		t = "Int"
	case objectTypeNumber:
		t = "Float"
	default:
		log.Fatalf("unknown type %q for %q", o.Type, o.jsonName)
	}

	values[jen.Id("Type")] = jen.Qual(importSchema, "Type"+t)
	if o.IsDeprecated {
		if o.DeprecationNotice == "" {
			log.Fatalf("missing deprecation notice for %q", o.jsonName)
		}
		values[jen.Id("Deprecated")] = jen.Lit(o.DeprecationNotice)
	}

	if o.CreateOnly {
		values[jen.Id("ForceNew")] = jen.True()
	}

	// Doesn't mark with required or optional scalar elements of arrays
	if !(o.isScalar() && o.parent.isArray()) {
		if o.Required {
			values[jen.Id("Required")] = jen.True()
		} else {
			values[jen.Id("Optional")] = jen.True()
		}
	}

	if o.isScalar() {
		if strings.Contains(o.jsonName, "api_key") || strings.Contains(o.jsonName, "password") {
			values[jen.Id("Sensitive")] = jen.True()
		}

		if o.Enum != nil {
			args := make([]jen.Code, 0)
			for _, v := range o.Enum {
				args = append(args, scalarLit(o, v.Value))
			}

			// There are no other types functions.
			// Bool and number won't compile
			switch o.Type {
			case objectTypeString:
				values[jen.Id("ValidateFunc")] = jen.Qual(importValidation, "StringInSlice").Call(scalarArrayLit(o, args), jen.False())
			case objectTypeInteger:
				values[jen.Id("ValidateFunc")] = jen.Qual(importValidation, "IntInSlice").Call(scalarArrayLit(o, args))
			}
		}

		return values
	}

	if o.isArray() {
		if o.ArrayItems.isScalar() {
			fields := getSchemaValues(o.ArrayItems)
			values[jen.Id("Elem")] = jen.Op("&").Qual(importSchema, "Schema").Values(fields)
			return values
		}

		// Renders the array as an object
		o = o.ArrayItems
	}

	if o.isRoot {
		values[jen.Id("DiffSuppressFunc")] = jen.Qual(importDiff, "SuppressUnchanged")
	}

	fields := make(jen.Dict)
	for _, p := range o.properties {
		fields[jen.Lit(p.tfName)] = jen.Values(getSchemaValues(p))
	}

	values[jen.Id("Elem")] = jen.Op("&").Qual(importSchema, "Resource").Values(jen.Dict{
		jen.Id("Schema"): jen.Map(jen.String()).Op("*").Qual(importSchema, "Schema").Values(fields),
	})

	return values
}

func getDescription(o *object) string {
	desc := make([]string, 0)
	d := o.Description
	if len(d) < len(o.Title) {
		d = o.Title
	}

	// Comes from the schema, quite confusing
	d = strings.TrimSuffix(d, "The default value is `map[]`.")
	if d != "" {
		desc = append(desc, addDot(d))
	}

	if o.isScalar() && o.Default != nil {
		desc = append(desc, fmt.Sprintf("The default value is `%v`.", o.Default))
	}

	// Trims dot from description, so it doesn't look weird with link to nested schema
	// Example: Databases to expose[dot] (see [below for nested schema]...)
	if len(desc) == 1 && o.isNestedBlock() {
		return strings.Trim(desc[0], ".")
	}

	return strings.Join(desc, " ")
}

func addDot(s string) string {
	if s != "" {
		switch s[len(s)-1:] {
		case ".", "!", "?":
		default:
			s += "."
		}
	}
	return s
}

var replaceDescriptionSubStrings = map[string]string{
	"UserConfig":                   "",
	"DEPRECATED: ":                 "",
	"This setting is deprecated. ": "",
	"[seconds]":                    "(seconds)",
}

func scalarLit(o *object, value any) *jen.Statement {
	switch o.Type {
	case objectTypeString:
		return jen.Lit(value.(string))
	case objectTypeBoolean:
		return jen.Lit(value.(bool))
	case objectTypeInteger:
		n, _ := strconv.Atoi(value.(string))
		return jen.Lit(n)
	case objectTypeNumber:
		return jen.Lit(value.(float64))
	}
	log.Fatalf("unknown scalar %v", o)
	return nil
}

func scalarArrayLit(o *object, args []jen.Code) *jen.Statement {
	switch o.Type {
	case objectTypeString:
		return jen.Index().String().Values(args...)
	case objectTypeInteger:
		return jen.Index().Int().Values(args...)
	}
	log.Fatalf("unexpected element type of array for default value: %q", o.Type)
	return nil
}
