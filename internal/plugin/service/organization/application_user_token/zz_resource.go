// Copyright (c) 2025 Aiven, Helsinki, Finland. https://aiven.io/
// Code generated by user config generator. DO NOT EDIT.

package applicationusertoken

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/aiven/terraform-provider-aiven/internal/plugin/adapter"
)

func newResourceModel() adapter.Model[tfModel] {
	return new(resourceModel)
}

// resourceModel with specific resource timeouts
type resourceModel struct {
	tfModel
	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

func (tf *resourceModel) SharedModel() *tfModel {
	return &tf.tfModel
}

/*
newResourceSchema:

	resource "aiven_organization_application_user_token" "example" {
	  description      = "test" // Force new
	  extend_when_used = false // Force new
	  ip_allowlist     = ["foo"] // Force new
	  max_age_seconds  = 42 // Force new
	  organization_id  = "org1a23f456789" // Force new
	  scopes           = ["foo"] // Force new
	  user_id          = "foo" // Force new

	  // COMPUTED FIELDS
	  create_time                    = "foo"
	  created_manually               = true
	  currently_active               = true
	  expiry_time                    = "foo"
	  full_token                     = "foo"
	  last_ip                        = "foo"
	  last_used_time                 = "foo"
	  last_user_agent                = "foo"
	  last_user_agent_human_readable = "foo"
	  token_prefix                   = "foo"
	}
*/
func newResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"create_time": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Create Time.",
			},
			"created_manually": schema.BoolAttribute{
				Computed:            true,
				MarkdownDescription: "True for tokens explicitly created via the access_tokens API, false for tokens created via login.",
			},
			"currently_active": schema.BoolAttribute{
				Computed:            true,
				MarkdownDescription: "true if API request was made with this access token.",
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Description. Maximum length: `1000`. Changing this property forces recreation of the resource.",
				Optional:            true,
				PlanModifiers:       []planmodifier.String{stringplanmodifier.RequiresReplace()},
				Validators:          []validator.String{stringvalidator.LengthAtMost(1000)},
			},
			"expiry_time": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Timestamp when the access token will expire unless extended, if ever.",
			},
			"extend_when_used": schema.BoolAttribute{
				Computed:            true,
				Default:             booldefault.StaticBool(false),
				MarkdownDescription: "Extend token expiration time when token is used. Only applicable if max_age_seconds is specified. The default value is `false`. Changing this property forces recreation of the resource.",
				Optional:            true,
				PlanModifiers:       []planmodifier.Bool{boolplanmodifier.RequiresReplace()},
			},
			"full_token": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Full Token.",
				Sensitive:           true,
			},
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Resource ID, a composite of `organization_id`, `user_id` and `token_prefix` IDs.",
				PlanModifiers:       []planmodifier.String{stringplanmodifier.UseStateForUnknown()},
			},
			"ip_allowlist": schema.SetAttribute{
				ElementType:         types.StringType,
				MarkdownDescription: "List of allowed IP ranges. Changing this property forces recreation of the resource.",
				Optional:            true,
				PlanModifiers:       []planmodifier.Set{setplanmodifier.RequiresReplace()},
				Validators:          []validator.Set{setvalidator.SizeAtMost(100)},
			},
			"last_ip": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "IP address the access token was last used from in case it has ever been used.",
			},
			"last_used_time": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Timestamp when the access token was last used, if ever.",
			},
			"last_user_agent": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "User agent string of the client that last used the token in case it has ever been used.",
			},
			"last_user_agent_human_readable": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Human readable user agent string of the client that last used the token in case user agent is known.",
			},
			"max_age_seconds": schema.Int64Attribute{
				MarkdownDescription: "Time the token remains valid since creation (or since last use if extend_when_used is true). Changing this property forces recreation of the resource.",
				Optional:            true,
				PlanModifiers:       []planmodifier.Int64{int64planmodifier.RequiresReplace()},
				Validators:          []validator.Int64{int64validator.Between(600, 315360000)},
			},
			"organization_id": schema.StringAttribute{
				MarkdownDescription: "ID of an organization. Changing this property forces recreation of the resource.",
				PlanModifiers:       []planmodifier.String{stringplanmodifier.RequiresReplace()},
				Required:            true,
			},
			"scopes": schema.SetAttribute{
				ElementType:         types.StringType,
				MarkdownDescription: "Scopes this token is restricted to if specified. Changing this property forces recreation of the resource.",
				Optional:            true,
				PlanModifiers:       []planmodifier.Set{setplanmodifier.RequiresReplace()},
				Validators:          []validator.Set{setvalidator.SizeAtMost(100)},
			},
			"token_prefix": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "First characters of the actual token value. Full value is only exposed after creation. This value is used when updating or revoking tokens. Note that the value may contain /, + and = characters and must be URL encoded when used (/ =&gt; %2F, + =&gt; %2B, = =&gt; %3D).",
			},
			"user_id": schema.StringAttribute{
				MarkdownDescription: "User ID. Changing this property forces recreation of the resource.",
				PlanModifiers:       []planmodifier.String{stringplanmodifier.RequiresReplace()},
				Required:            true,
			},
		},
		Blocks:              map[string]schema.Block{"timeouts": timeouts.BlockAll(ctx)},
		MarkdownDescription: "Creates and manages an application user token. Review the [best practices](https://aiven.io/docs/platform/concepts/application-users#security-best-practices) for securing application users and their tokens.",
	}
}
