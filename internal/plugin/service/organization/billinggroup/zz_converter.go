// Copyright (c) 2026 Aiven, Helsinki, Finland. https://aiven.io/
// Code generated by user config generator. DO NOT EDIT.

package billinggroup

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/aiven/terraform-provider-aiven/internal/plugin/util"
)

const typeName = "aiven_organization_billing_group"

type tfModel struct {
	ID                   types.String `tfsdk:"id"`
	BillingAddressID     types.String `tfsdk:"billing_address_id"`
	BillingContactEmails types.Set    `tfsdk:"billing_contact_emails"`
	BillingEmails        types.Set    `tfsdk:"billing_emails"`
	BillingGroupID       types.String `tfsdk:"billing_group_id"`
	BillingGroupName     types.String `tfsdk:"billing_group_name"`
	Currency             types.String `tfsdk:"currency"`
	CustomInvoiceText    types.String `tfsdk:"custom_invoice_text"`
	OrganizationID       types.String `tfsdk:"organization_id"`
	PaymentMethod        types.List   `tfsdk:"payment_method"`
	ShippingAddressID    types.String `tfsdk:"shipping_address_id"`
	VatID                types.String `tfsdk:"vat_id"`
}

func (tf *tfModel) SetID(vOrganizationID string, vBillingGroupID string) {
	tf.OrganizationID = types.StringValue(vOrganizationID)
	tf.BillingGroupID = types.StringValue(vBillingGroupID)
	tf.ID = types.StringValue(filepath.Join(vOrganizationID, vBillingGroupID))
}

type tfModelBillingContactEmails struct {
	Email types.String `tfsdk:"email"`
}

type tfModelBillingEmails struct {
	Email types.String `tfsdk:"email"`
}

type tfModelPaymentMethod struct {
	PaymentMethodID   types.String `tfsdk:"payment_method_id"`
	PaymentMethodType types.String `tfsdk:"payment_method_type"`
}

type apiModel struct {
	BillingAddressID     *string                          `json:"billing_address_id,omitempty"`
	BillingContactEmails *[]*apiModelBillingContactEmails `json:"billing_contact_emails,omitempty"`
	BillingEmails        *[]*apiModelBillingEmails        `json:"billing_emails,omitempty"`
	BillingGroupID       *string                          `json:"billing_group_id,omitempty"`
	BillingGroupName     *string                          `json:"billing_group_name,omitempty"`
	Currency             *string                          `json:"currency,omitempty"`
	CustomInvoiceText    *string                          `json:"custom_invoice_text,omitempty"`
	OrganizationID       *string                          `json:"organization_id,omitempty"`
	PaymentMethod        *apiModelPaymentMethod           `json:"payment_method,omitempty"`
	ShippingAddressID    *string                          `json:"shipping_address_id,omitempty"`
	VatID                *string                          `json:"vat_id,omitempty"`
}

type apiModelBillingContactEmails struct {
	Email *string `json:"email,omitempty"`
}

type apiModelBillingEmails struct {
	Email *string `json:"email,omitempty"`
}

type apiModelPaymentMethod struct {
	PaymentMethodID   *string `json:"payment_method_id,omitempty"`
	PaymentMethodType *string `json:"payment_method_type,omitempty"`
}

// idFields the ID attribute fields, i.e.:
// terraform import aiven_organization_billing_group.foo ORGANIZATION_ID/BILLING_GROUP_ID
func idFields() []string {
	return []string{"organization_id", "billing_group_id"}
}

// expandData turns TF object into Request
func expandData[R any](ctx context.Context, plan, state *tfModel, req *R, modifiers ...util.MapModifier[tfModel]) diag.Diagnostics {
	api := new(apiModel)
	if !plan.BillingContactEmails.IsNull() || state != nil && !state.BillingContactEmails.IsNull() {
		vBillingContactEmails, diags := util.ExpandSetNested(ctx, expandBillingContactEmails, plan.BillingContactEmails)
		if diags.HasError() {
			return diags
		}
		api.BillingContactEmails = &vBillingContactEmails
	}
	if !plan.BillingEmails.IsNull() || state != nil && !state.BillingEmails.IsNull() {
		vBillingEmails, diags := util.ExpandSetNested(ctx, expandBillingEmails, plan.BillingEmails)
		if diags.HasError() {
			return diags
		}
		api.BillingEmails = &vBillingEmails
	}
	if !plan.PaymentMethod.IsNull() || state != nil && !state.PaymentMethod.IsNull() {
		vPaymentMethod, diags := util.ExpandSingleNested(ctx, expandPaymentMethod, plan.PaymentMethod)
		if diags.HasError() {
			return diags
		}
		api.PaymentMethod = vPaymentMethod
	}
	if !plan.BillingAddressID.IsNull() || state != nil && !state.BillingAddressID.IsNull() {
		vBillingAddressID := plan.BillingAddressID.ValueString()
		api.BillingAddressID = &vBillingAddressID
	}
	if !plan.BillingGroupName.IsNull() || state != nil && !state.BillingGroupName.IsNull() {
		vBillingGroupName := plan.BillingGroupName.ValueString()
		api.BillingGroupName = &vBillingGroupName
	}
	if !plan.CustomInvoiceText.IsNull() || state != nil && !state.CustomInvoiceText.IsNull() {
		vCustomInvoiceText := plan.CustomInvoiceText.ValueString()
		api.CustomInvoiceText = &vCustomInvoiceText
	}
	if !plan.OrganizationID.IsNull() || state != nil && !state.OrganizationID.IsNull() {
		vOrganizationID := plan.OrganizationID.ValueString()
		api.OrganizationID = &vOrganizationID
	}
	if !plan.ShippingAddressID.IsNull() || state != nil && !state.ShippingAddressID.IsNull() {
		vShippingAddressID := plan.ShippingAddressID.ValueString()
		api.ShippingAddressID = &vShippingAddressID
	}
	if !plan.VatID.IsNull() || state != nil && !state.VatID.IsNull() {
		vVatID := plan.VatID.ValueString()
		api.VatID = &vVatID
	}
	err := util.Remarshal(api, req, plan, modifiers...)
	if err != nil {
		var diags diag.Diagnostics
		diags.AddError("Remarshal error", fmt.Sprintf("Failed to remarshal dtoModel to Request: %s", err.Error()))
		return diags
	}
	return nil
}

func expandBillingContactEmails(ctx context.Context, plan *tfModelBillingContactEmails) (*apiModelBillingContactEmails, diag.Diagnostics) {
	api := new(apiModelBillingContactEmails)
	if !plan.Email.IsNull() {
		vEmail := plan.Email.ValueString()
		api.Email = &vEmail
	}
	return api, nil
}

func expandBillingEmails(ctx context.Context, plan *tfModelBillingEmails) (*apiModelBillingEmails, diag.Diagnostics) {
	api := new(apiModelBillingEmails)
	if !plan.Email.IsNull() {
		vEmail := plan.Email.ValueString()
		api.Email = &vEmail
	}
	return api, nil
}

func expandPaymentMethod(ctx context.Context, plan *tfModelPaymentMethod) (*apiModelPaymentMethod, diag.Diagnostics) {
	api := new(apiModelPaymentMethod)
	if !plan.PaymentMethodID.IsNull() {
		vPaymentMethodID := plan.PaymentMethodID.ValueString()
		api.PaymentMethodID = &vPaymentMethodID
	}
	if !plan.PaymentMethodType.IsNull() {
		vPaymentMethodType := plan.PaymentMethodType.ValueString()
		api.PaymentMethodType = &vPaymentMethodType
	}
	return api, nil
}

// flattenData turns Response into TF object
func flattenData[R any](ctx context.Context, state *tfModel, rsp *R, modifiers ...util.MapModifier[tfModel]) diag.Diagnostics {
	api := new(apiModel)
	err := util.Remarshal(rsp, api, state, modifiers...)
	if err != nil {
		var diags diag.Diagnostics
		diags.AddError("Remarshal error", fmt.Sprintf("Failed to remarshal Response to dtoModel: %s", err.Error()))
		return diags
	}
	if api.BillingContactEmails != nil && !state.BillingContactEmails.IsUnknown() {
		vBillingContactEmails, diags := util.FlattenSetNested(ctx, flattenBillingContactEmails, *api.BillingContactEmails, attrsBillingContactEmails())
		if diags.HasError() {
			return diags
		}
		state.BillingContactEmails = vBillingContactEmails
	}
	if api.BillingEmails != nil && !state.BillingEmails.IsUnknown() {
		vBillingEmails, diags := util.FlattenSetNested(ctx, flattenBillingEmails, *api.BillingEmails, attrsBillingEmails())
		if diags.HasError() {
			return diags
		}
		state.BillingEmails = vBillingEmails
	}
	if api.PaymentMethod != nil && !state.PaymentMethod.IsUnknown() {
		vPaymentMethod, diags := util.FlattenSingleNested(ctx, flattenPaymentMethod, api.PaymentMethod, attrsPaymentMethod())
		if diags.HasError() {
			return diags
		}
		state.PaymentMethod = vPaymentMethod
	}
	if api.BillingAddressID != nil && !state.BillingAddressID.IsUnknown() {
		state.BillingAddressID = util.StringPointerValue(api.BillingAddressID)
	}
	if api.BillingGroupID != nil || state.BillingGroupID.IsUnknown() {
		state.BillingGroupID = util.StringPointerValue(api.BillingGroupID)
	}
	if api.BillingGroupName != nil && !state.BillingGroupName.IsUnknown() {
		state.BillingGroupName = util.StringPointerValue(api.BillingGroupName)
	}
	if api.Currency != nil || state.Currency.IsUnknown() {
		state.Currency = util.StringPointerValue(api.Currency)
	}
	if api.CustomInvoiceText != nil && !state.CustomInvoiceText.IsUnknown() {
		state.CustomInvoiceText = util.StringPointerValue(api.CustomInvoiceText)
	}
	if api.OrganizationID != nil && !state.OrganizationID.IsUnknown() {
		state.OrganizationID = util.StringPointerValue(api.OrganizationID)
	}
	if api.ShippingAddressID != nil && !state.ShippingAddressID.IsUnknown() {
		state.ShippingAddressID = util.StringPointerValue(api.ShippingAddressID)
	}
	if api.VatID != nil && !state.VatID.IsUnknown() {
		state.VatID = util.StringPointerValue(api.VatID)
	}
	// Response may not contain ID fields.
	// In that case, `terraform import` won't be able to set them. Gets values from the ID.
	if state.ID.ValueString() != "" {
		var parts [2]string
		for i, v := range strings.SplitN(state.ID.ValueString(), "/", 2) {
			parts[i] = v
		}
		if state.OrganizationID.ValueString() == "" {
			state.OrganizationID = types.StringValue(parts[0])
		}
		if state.BillingGroupID.ValueString() == "" {
			state.BillingGroupID = types.StringValue(parts[1])
		}
	}
	state.SetID(state.OrganizationID.ValueString(), state.BillingGroupID.ValueString())
	return nil
}

func flattenBillingContactEmails(ctx context.Context, api *apiModelBillingContactEmails) (*tfModelBillingContactEmails, diag.Diagnostics) {
	state := new(tfModelBillingContactEmails)
	if api.Email != nil {
		state.Email = util.StringPointerValue(api.Email)
	}
	return state, nil
}

func flattenBillingEmails(ctx context.Context, api *apiModelBillingEmails) (*tfModelBillingEmails, diag.Diagnostics) {
	state := new(tfModelBillingEmails)
	if api.Email != nil {
		state.Email = util.StringPointerValue(api.Email)
	}
	return state, nil
}

func flattenPaymentMethod(ctx context.Context, api *apiModelPaymentMethod) (*tfModelPaymentMethod, diag.Diagnostics) {
	state := new(tfModelPaymentMethod)
	if api.PaymentMethodID != nil {
		state.PaymentMethodID = util.StringPointerValue(api.PaymentMethodID)
	}
	if api.PaymentMethodType != nil {
		state.PaymentMethodType = util.StringPointerValue(api.PaymentMethodType)
	}
	return state, nil
}

func attrsBillingContactEmails() types.ObjectType {
	return types.ObjectType{AttrTypes: map[string]attr.Type{"email": types.StringType}}
}

func attrsBillingEmails() types.ObjectType {
	return types.ObjectType{AttrTypes: map[string]attr.Type{"email": types.StringType}}
}

func attrsPaymentMethod() types.ObjectType {
	return types.ObjectType{AttrTypes: map[string]attr.Type{
		"payment_method_id":   types.StringType,
		"payment_method_type": types.StringType,
	}}
}
