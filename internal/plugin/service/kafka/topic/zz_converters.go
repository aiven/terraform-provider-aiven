// Copyright (c) 2025 Aiven, Helsinki, Finland. https://aiven.io/
// Code generated by user config generator. DO NOT EDIT.

package topic

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/aiven/terraform-provider-aiven/internal/plugin/util"
)

const aivenName = "aiven_kafka_topic"

type tfModel struct {
	ID                    types.String `tfsdk:"id"`
	Config                types.List   `tfsdk:"config"`
	OwnerUserGroupID      types.String `tfsdk:"owner_user_group_id"`
	Partitions            types.Int64  `tfsdk:"partitions"`
	Project               types.String `tfsdk:"project"`
	Replication           types.Int64  `tfsdk:"replication"`
	ServiceName           types.String `tfsdk:"service_name"`
	Tag                   types.Set    `tfsdk:"tag"`
	TerminationProtection types.Bool   `tfsdk:"termination_protection"`
	TopicDescription      types.String `tfsdk:"topic_description"`
	TopicName             types.String `tfsdk:"topic_name"`
}

func (tf *tfModel) SetID(vProject string, vServiceName string, vTopicName string) {
	tf.Project = types.StringValue(vProject)
	tf.ServiceName = types.StringValue(vServiceName)
	tf.TopicName = types.StringValue(vTopicName)
	tf.ID = types.StringValue(filepath.Join(vProject, vServiceName, vTopicName))
}

type tfModelConfig struct {
	CleanupPolicy                   types.String  `tfsdk:"cleanup_policy"`
	CompressionType                 types.String  `tfsdk:"compression_type"`
	DeleteRetentionMs               types.String  `tfsdk:"delete_retention_ms"`
	DisklessEnable                  types.Bool    `tfsdk:"diskless_enable"`
	FileDeleteDelayMs               types.String  `tfsdk:"file_delete_delay_ms"`
	FlushMessages                   types.String  `tfsdk:"flush_messages"`
	FlushMs                         types.String  `tfsdk:"flush_ms"`
	IndexIntervalBytes              types.String  `tfsdk:"index_interval_bytes"`
	LocalRetentionBytes             types.String  `tfsdk:"local_retention_bytes"`
	LocalRetentionMs                types.String  `tfsdk:"local_retention_ms"`
	MaxCompactionLagMs              types.String  `tfsdk:"max_compaction_lag_ms"`
	MaxMessageBytes                 types.String  `tfsdk:"max_message_bytes"`
	MessageDownconversionEnable     types.Bool    `tfsdk:"message_downconversion_enable"`
	MessageFormatVersion            types.String  `tfsdk:"message_format_version"`
	MessageTimestampAfterMaxMs      types.Int64   `tfsdk:"message_timestamp_after_max_ms"`
	MessageTimestampBeforeMaxMs     types.Int64   `tfsdk:"message_timestamp_before_max_ms"`
	MessageTimestampDifferenceMaxMs types.String  `tfsdk:"message_timestamp_difference_max_ms"`
	MessageTimestampType            types.String  `tfsdk:"message_timestamp_type"`
	MinCleanableDirtyRatio          types.Float64 `tfsdk:"min_cleanable_dirty_ratio"`
	MinCompactionLagMs              types.String  `tfsdk:"min_compaction_lag_ms"`
	MinInsyncReplicas               types.String  `tfsdk:"min_insync_replicas"`
	Preallocate                     types.Bool    `tfsdk:"preallocate"`
	RemoteStorageEnable             types.Bool    `tfsdk:"remote_storage_enable"`
	RetentionBytes                  types.String  `tfsdk:"retention_bytes"`
	RetentionMs                     types.String  `tfsdk:"retention_ms"`
	SegmentBytes                    types.String  `tfsdk:"segment_bytes"`
	SegmentIndexBytes               types.String  `tfsdk:"segment_index_bytes"`
	SegmentJitterMs                 types.String  `tfsdk:"segment_jitter_ms"`
	SegmentMs                       types.String  `tfsdk:"segment_ms"`
	UncleanLeaderElectionEnable     types.Bool    `tfsdk:"unclean_leader_election_enable"`
}

type tfModelTag struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

type apiModel struct {
	Config                *apiModelConfig `json:"config,omitempty"`
	OwnerUserGroupID      *string         `json:"owner_user_group_id,omitempty"`
	Partitions            *int64          `json:"partitions,omitempty"`
	Project               *string         `json:"project,omitempty"`
	Replication           *int64          `json:"replication,omitempty"`
	ServiceName           *string         `json:"service_name,omitempty"`
	Tag                   *[]*apiModelTag `json:"tags,omitempty"`
	TerminationProtection *bool           `json:"termination_protection,omitempty"`
	TopicDescription      *string         `json:"topic_description,omitempty"`
	TopicName             *string         `json:"topic_name,omitempty"`
}

type apiModelConfig struct {
	CleanupPolicy                   *string  `json:"cleanup_policy,omitempty"`
	CompressionType                 *string  `json:"compression_type,omitempty"`
	DeleteRetentionMs               *string  `json:"delete_retention_ms,omitempty"`
	DisklessEnable                  *bool    `json:"diskless_enable,omitempty"`
	FileDeleteDelayMs               *string  `json:"file_delete_delay_ms,omitempty"`
	FlushMessages                   *string  `json:"flush_messages,omitempty"`
	FlushMs                         *string  `json:"flush_ms,omitempty"`
	IndexIntervalBytes              *string  `json:"index_interval_bytes,omitempty"`
	LocalRetentionBytes             *string  `json:"local_retention_bytes,omitempty"`
	LocalRetentionMs                *string  `json:"local_retention_ms,omitempty"`
	MaxCompactionLagMs              *string  `json:"max_compaction_lag_ms,omitempty"`
	MaxMessageBytes                 *string  `json:"max_message_bytes,omitempty"`
	MessageDownconversionEnable     *bool    `json:"message_downconversion_enable,omitempty"`
	MessageFormatVersion            *string  `json:"message_format_version,omitempty"`
	MessageTimestampAfterMaxMs      *int64   `json:"message_timestamp_after_max_ms,omitempty"`
	MessageTimestampBeforeMaxMs     *int64   `json:"message_timestamp_before_max_ms,omitempty"`
	MessageTimestampDifferenceMaxMs *string  `json:"message_timestamp_difference_max_ms,omitempty"`
	MessageTimestampType            *string  `json:"message_timestamp_type,omitempty"`
	MinCleanableDirtyRatio          *float64 `json:"min_cleanable_dirty_ratio,omitempty"`
	MinCompactionLagMs              *string  `json:"min_compaction_lag_ms,omitempty"`
	MinInsyncReplicas               *string  `json:"min_insync_replicas,omitempty"`
	Preallocate                     *bool    `json:"preallocate,omitempty"`
	RemoteStorageEnable             *bool    `json:"remote_storage_enable,omitempty"`
	RetentionBytes                  *string  `json:"retention_bytes,omitempty"`
	RetentionMs                     *string  `json:"retention_ms,omitempty"`
	SegmentBytes                    *string  `json:"segment_bytes,omitempty"`
	SegmentIndexBytes               *string  `json:"segment_index_bytes,omitempty"`
	SegmentJitterMs                 *string  `json:"segment_jitter_ms,omitempty"`
	SegmentMs                       *string  `json:"segment_ms,omitempty"`
	UncleanLeaderElectionEnable     *bool    `json:"unclean_leader_election_enable,omitempty"`
}

type apiModelTag struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// composeID the ID attribute fields, i.e.:
// terraform import aiven_kafka_topic.foo PROJECT/SERVICE_NAME/TOPIC_NAME
func composeID() []string {
	return []string{"project", "service_name", "topic_name"}
}

// expandData turns TF object into Request
func expandData[R any](ctx context.Context, plan, state *tfModel, req *R, modifiers ...util.MapModifier[apiModel]) diag.Diagnostics {
	api := new(apiModel)
	if !plan.Config.IsNull() && !plan.Config.IsUnknown() {
		vConfig, diags := util.ExpandSingleNested(ctx, expandConfig, plan.Config)
		if diags.HasError() {
			return diags
		}
		api.Config = vConfig
	}
	if !plan.Tag.IsNull() || state != nil && !state.Tag.IsNull() {
		vTag, diags := util.ExpandSetNested(ctx, expandTag, plan.Tag)
		if diags.HasError() {
			return diags
		}
		api.Tag = &vTag
	}
	if !plan.OwnerUserGroupID.IsNull() && !plan.OwnerUserGroupID.IsUnknown() {
		vOwnerUserGroupID := plan.OwnerUserGroupID.ValueString()
		api.OwnerUserGroupID = &vOwnerUserGroupID
	}
	if !plan.Partitions.IsNull() || state != nil && !state.Partitions.IsNull() {
		vPartitions := plan.Partitions.ValueInt64()
		api.Partitions = &vPartitions
	}
	if !plan.Project.IsNull() || state != nil && !state.Project.IsNull() {
		vProject := plan.Project.ValueString()
		api.Project = &vProject
	}
	if !plan.Replication.IsNull() || state != nil && !state.Replication.IsNull() {
		vReplication := plan.Replication.ValueInt64()
		api.Replication = &vReplication
	}
	if !plan.ServiceName.IsNull() || state != nil && !state.ServiceName.IsNull() {
		vServiceName := plan.ServiceName.ValueString()
		api.ServiceName = &vServiceName
	}
	if !plan.TerminationProtection.IsNull() && !plan.TerminationProtection.IsUnknown() {
		vTerminationProtection := plan.TerminationProtection.ValueBool()
		api.TerminationProtection = &vTerminationProtection
	}
	if !plan.TopicDescription.IsNull() && !plan.TopicDescription.IsUnknown() {
		vTopicDescription := plan.TopicDescription.ValueString()
		api.TopicDescription = &vTopicDescription
	}
	if !plan.TopicName.IsNull() || state != nil && !state.TopicName.IsNull() {
		vTopicName := plan.TopicName.ValueString()
		api.TopicName = &vTopicName
	}
	err := util.Remarshal(api, req, modifiers...)
	if err != nil {
		var diags diag.Diagnostics
		diags.AddError("Remarshal error", fmt.Sprintf("Failed to remarshal dtoModel to Request: %s", err.Error()))
		return diags
	}
	return nil
}

func expandConfig(ctx context.Context, plan *tfModelConfig) (*apiModelConfig, diag.Diagnostics) {
	api := new(apiModelConfig)
	if !plan.CleanupPolicy.IsNull() && !plan.CleanupPolicy.IsUnknown() {
		vCleanupPolicy := plan.CleanupPolicy.ValueString()
		api.CleanupPolicy = &vCleanupPolicy
	}
	if !plan.CompressionType.IsNull() && !plan.CompressionType.IsUnknown() {
		vCompressionType := plan.CompressionType.ValueString()
		api.CompressionType = &vCompressionType
	}
	if !plan.DeleteRetentionMs.IsNull() && !plan.DeleteRetentionMs.IsUnknown() {
		vDeleteRetentionMs := plan.DeleteRetentionMs.ValueString()
		api.DeleteRetentionMs = &vDeleteRetentionMs
	}
	if !plan.DisklessEnable.IsNull() && !plan.DisklessEnable.IsUnknown() {
		vDisklessEnable := plan.DisklessEnable.ValueBool()
		api.DisklessEnable = &vDisklessEnable
	}
	if !plan.FileDeleteDelayMs.IsNull() && !plan.FileDeleteDelayMs.IsUnknown() {
		vFileDeleteDelayMs := plan.FileDeleteDelayMs.ValueString()
		api.FileDeleteDelayMs = &vFileDeleteDelayMs
	}
	if !plan.FlushMessages.IsNull() && !plan.FlushMessages.IsUnknown() {
		vFlushMessages := plan.FlushMessages.ValueString()
		api.FlushMessages = &vFlushMessages
	}
	if !plan.FlushMs.IsNull() && !plan.FlushMs.IsUnknown() {
		vFlushMs := plan.FlushMs.ValueString()
		api.FlushMs = &vFlushMs
	}
	if !plan.IndexIntervalBytes.IsNull() && !plan.IndexIntervalBytes.IsUnknown() {
		vIndexIntervalBytes := plan.IndexIntervalBytes.ValueString()
		api.IndexIntervalBytes = &vIndexIntervalBytes
	}
	if !plan.LocalRetentionBytes.IsNull() && !plan.LocalRetentionBytes.IsUnknown() {
		vLocalRetentionBytes := plan.LocalRetentionBytes.ValueString()
		api.LocalRetentionBytes = &vLocalRetentionBytes
	}
	if !plan.LocalRetentionMs.IsNull() && !plan.LocalRetentionMs.IsUnknown() {
		vLocalRetentionMs := plan.LocalRetentionMs.ValueString()
		api.LocalRetentionMs = &vLocalRetentionMs
	}
	if !plan.MaxCompactionLagMs.IsNull() && !plan.MaxCompactionLagMs.IsUnknown() {
		vMaxCompactionLagMs := plan.MaxCompactionLagMs.ValueString()
		api.MaxCompactionLagMs = &vMaxCompactionLagMs
	}
	if !plan.MaxMessageBytes.IsNull() && !plan.MaxMessageBytes.IsUnknown() {
		vMaxMessageBytes := plan.MaxMessageBytes.ValueString()
		api.MaxMessageBytes = &vMaxMessageBytes
	}
	if !plan.MessageDownconversionEnable.IsNull() && !plan.MessageDownconversionEnable.IsUnknown() {
		vMessageDownconversionEnable := plan.MessageDownconversionEnable.ValueBool()
		api.MessageDownconversionEnable = &vMessageDownconversionEnable
	}
	if !plan.MessageFormatVersion.IsNull() && !plan.MessageFormatVersion.IsUnknown() {
		vMessageFormatVersion := plan.MessageFormatVersion.ValueString()
		api.MessageFormatVersion = &vMessageFormatVersion
	}
	if !plan.MessageTimestampAfterMaxMs.IsNull() && !plan.MessageTimestampAfterMaxMs.IsUnknown() {
		vMessageTimestampAfterMaxMs := plan.MessageTimestampAfterMaxMs.ValueInt64()
		api.MessageTimestampAfterMaxMs = &vMessageTimestampAfterMaxMs
	}
	if !plan.MessageTimestampBeforeMaxMs.IsNull() && !plan.MessageTimestampBeforeMaxMs.IsUnknown() {
		vMessageTimestampBeforeMaxMs := plan.MessageTimestampBeforeMaxMs.ValueInt64()
		api.MessageTimestampBeforeMaxMs = &vMessageTimestampBeforeMaxMs
	}
	if !plan.MessageTimestampDifferenceMaxMs.IsNull() && !plan.MessageTimestampDifferenceMaxMs.IsUnknown() {
		vMessageTimestampDifferenceMaxMs := plan.MessageTimestampDifferenceMaxMs.ValueString()
		api.MessageTimestampDifferenceMaxMs = &vMessageTimestampDifferenceMaxMs
	}
	if !plan.MessageTimestampType.IsNull() && !plan.MessageTimestampType.IsUnknown() {
		vMessageTimestampType := plan.MessageTimestampType.ValueString()
		api.MessageTimestampType = &vMessageTimestampType
	}
	if !plan.MinCleanableDirtyRatio.IsNull() && !plan.MinCleanableDirtyRatio.IsUnknown() {
		vMinCleanableDirtyRatio := plan.MinCleanableDirtyRatio.ValueFloat64()
		api.MinCleanableDirtyRatio = &vMinCleanableDirtyRatio
	}
	if !plan.MinCompactionLagMs.IsNull() && !plan.MinCompactionLagMs.IsUnknown() {
		vMinCompactionLagMs := plan.MinCompactionLagMs.ValueString()
		api.MinCompactionLagMs = &vMinCompactionLagMs
	}
	if !plan.MinInsyncReplicas.IsNull() && !plan.MinInsyncReplicas.IsUnknown() {
		vMinInsyncReplicas := plan.MinInsyncReplicas.ValueString()
		api.MinInsyncReplicas = &vMinInsyncReplicas
	}
	if !plan.Preallocate.IsNull() && !plan.Preallocate.IsUnknown() {
		vPreallocate := plan.Preallocate.ValueBool()
		api.Preallocate = &vPreallocate
	}
	if !plan.RemoteStorageEnable.IsNull() && !plan.RemoteStorageEnable.IsUnknown() {
		vRemoteStorageEnable := plan.RemoteStorageEnable.ValueBool()
		api.RemoteStorageEnable = &vRemoteStorageEnable
	}
	if !plan.RetentionBytes.IsNull() && !plan.RetentionBytes.IsUnknown() {
		vRetentionBytes := plan.RetentionBytes.ValueString()
		api.RetentionBytes = &vRetentionBytes
	}
	if !plan.RetentionMs.IsNull() && !plan.RetentionMs.IsUnknown() {
		vRetentionMs := plan.RetentionMs.ValueString()
		api.RetentionMs = &vRetentionMs
	}
	if !plan.SegmentBytes.IsNull() && !plan.SegmentBytes.IsUnknown() {
		vSegmentBytes := plan.SegmentBytes.ValueString()
		api.SegmentBytes = &vSegmentBytes
	}
	if !plan.SegmentIndexBytes.IsNull() && !plan.SegmentIndexBytes.IsUnknown() {
		vSegmentIndexBytes := plan.SegmentIndexBytes.ValueString()
		api.SegmentIndexBytes = &vSegmentIndexBytes
	}
	if !plan.SegmentJitterMs.IsNull() && !plan.SegmentJitterMs.IsUnknown() {
		vSegmentJitterMs := plan.SegmentJitterMs.ValueString()
		api.SegmentJitterMs = &vSegmentJitterMs
	}
	if !plan.SegmentMs.IsNull() && !plan.SegmentMs.IsUnknown() {
		vSegmentMs := plan.SegmentMs.ValueString()
		api.SegmentMs = &vSegmentMs
	}
	if !plan.UncleanLeaderElectionEnable.IsNull() && !plan.UncleanLeaderElectionEnable.IsUnknown() {
		vUncleanLeaderElectionEnable := plan.UncleanLeaderElectionEnable.ValueBool()
		api.UncleanLeaderElectionEnable = &vUncleanLeaderElectionEnable
	}
	return api, nil
}

func expandTag(ctx context.Context, plan *tfModelTag) (*apiModelTag, diag.Diagnostics) {
	api := new(apiModelTag)
	if !plan.Key.IsNull() {
		vKey := plan.Key.ValueString()
		api.Key = &vKey
	}
	if !plan.Value.IsNull() {
		vValue := plan.Value.ValueString()
		api.Value = &vValue
	}
	return api, nil
}

// flattenData turns Response into TF object
func flattenData[R any](ctx context.Context, state *tfModel, rsp *R, modifiers ...util.MapModifier[R]) diag.Diagnostics {
	api := new(apiModel)
	err := util.Remarshal(rsp, api, modifiers...)
	if err != nil {
		var diags diag.Diagnostics
		diags.AddError("Remarshal error", fmt.Sprintf("Failed to remarshal Response to dtoModel: %s", err.Error()))
		return diags
	}
	if api.Config != nil {
		vConfig, diags := util.FlattenSingleNested(ctx, flattenConfig, api.Config, attrsConfig())
		if diags.HasError() {
			return diags
		}
		state.Config = vConfig
	}
	if api.Tag != nil {
		vTag, diags := util.FlattenSetNested(ctx, flattenTag, *api.Tag, attrsTag())
		if diags.HasError() {
			return diags
		}
		state.Tag = vTag
	}
	if api.OwnerUserGroupID != nil && (*api.OwnerUserGroupID != "" || !state.OwnerUserGroupID.IsNull()) {
		state.OwnerUserGroupID = types.StringPointerValue(api.OwnerUserGroupID)
	}
	if api.Partitions != nil {
		state.Partitions = types.Int64PointerValue(api.Partitions)
	}
	if api.Project != nil && (*api.Project != "" || !state.Project.IsNull()) {
		state.Project = types.StringPointerValue(api.Project)
	}
	if api.Replication != nil {
		state.Replication = types.Int64PointerValue(api.Replication)
	}
	if api.ServiceName != nil && (*api.ServiceName != "" || !state.ServiceName.IsNull()) {
		state.ServiceName = types.StringPointerValue(api.ServiceName)
	}
	if api.TerminationProtection != nil {
		state.TerminationProtection = types.BoolPointerValue(api.TerminationProtection)
	}
	if api.TopicDescription != nil && (*api.TopicDescription != "" || !state.TopicDescription.IsNull()) {
		state.TopicDescription = types.StringPointerValue(api.TopicDescription)
	}
	if api.TopicName != nil && (*api.TopicName != "" || !state.TopicName.IsNull()) {
		state.TopicName = types.StringPointerValue(api.TopicName)
	}
	// Response may not contain ID fields.
	// In that case, `terraform import` won't be able to set them. Gets values from the ID.
	if state.ID.ValueString() != "" {
		var parts [3]string
		for i, v := range strings.SplitN(state.ID.ValueString(), "/", 3) {
			parts[i] = v
		}
		if state.Project.ValueString() == "" {
			state.Project = types.StringValue(parts[0])
		}
		if state.ServiceName.ValueString() == "" {
			state.ServiceName = types.StringValue(parts[1])
		}
		if state.TopicName.ValueString() == "" {
			state.TopicName = types.StringValue(parts[2])
		}
	}
	state.SetID(state.Project.ValueString(), state.ServiceName.ValueString(), state.TopicName.ValueString())
	return nil
}

func flattenConfig(ctx context.Context, api *apiModelConfig) (*tfModelConfig, diag.Diagnostics) {
	state := new(tfModelConfig)
	if api.CleanupPolicy != nil {
		state.CleanupPolicy = types.StringPointerValue(api.CleanupPolicy)
	}
	if api.CompressionType != nil {
		state.CompressionType = types.StringPointerValue(api.CompressionType)
	}
	if api.DeleteRetentionMs != nil {
		state.DeleteRetentionMs = types.StringPointerValue(api.DeleteRetentionMs)
	}
	if api.DisklessEnable != nil {
		state.DisklessEnable = types.BoolPointerValue(api.DisklessEnable)
	}
	if api.FileDeleteDelayMs != nil {
		state.FileDeleteDelayMs = types.StringPointerValue(api.FileDeleteDelayMs)
	}
	if api.FlushMessages != nil {
		state.FlushMessages = types.StringPointerValue(api.FlushMessages)
	}
	if api.FlushMs != nil {
		state.FlushMs = types.StringPointerValue(api.FlushMs)
	}
	if api.IndexIntervalBytes != nil {
		state.IndexIntervalBytes = types.StringPointerValue(api.IndexIntervalBytes)
	}
	if api.LocalRetentionBytes != nil {
		state.LocalRetentionBytes = types.StringPointerValue(api.LocalRetentionBytes)
	}
	if api.LocalRetentionMs != nil {
		state.LocalRetentionMs = types.StringPointerValue(api.LocalRetentionMs)
	}
	if api.MaxCompactionLagMs != nil {
		state.MaxCompactionLagMs = types.StringPointerValue(api.MaxCompactionLagMs)
	}
	if api.MaxMessageBytes != nil {
		state.MaxMessageBytes = types.StringPointerValue(api.MaxMessageBytes)
	}
	if api.MessageDownconversionEnable != nil {
		state.MessageDownconversionEnable = types.BoolPointerValue(api.MessageDownconversionEnable)
	}
	if api.MessageFormatVersion != nil {
		state.MessageFormatVersion = types.StringPointerValue(api.MessageFormatVersion)
	}
	if api.MessageTimestampAfterMaxMs != nil {
		state.MessageTimestampAfterMaxMs = types.Int64PointerValue(api.MessageTimestampAfterMaxMs)
	}
	if api.MessageTimestampBeforeMaxMs != nil {
		state.MessageTimestampBeforeMaxMs = types.Int64PointerValue(api.MessageTimestampBeforeMaxMs)
	}
	if api.MessageTimestampDifferenceMaxMs != nil {
		state.MessageTimestampDifferenceMaxMs = types.StringPointerValue(api.MessageTimestampDifferenceMaxMs)
	}
	if api.MessageTimestampType != nil {
		state.MessageTimestampType = types.StringPointerValue(api.MessageTimestampType)
	}
	if api.MinCleanableDirtyRatio != nil {
		state.MinCleanableDirtyRatio = types.Float64PointerValue(api.MinCleanableDirtyRatio)
	}
	if api.MinCompactionLagMs != nil {
		state.MinCompactionLagMs = types.StringPointerValue(api.MinCompactionLagMs)
	}
	if api.MinInsyncReplicas != nil {
		state.MinInsyncReplicas = types.StringPointerValue(api.MinInsyncReplicas)
	}
	if api.Preallocate != nil {
		state.Preallocate = types.BoolPointerValue(api.Preallocate)
	}
	if api.RemoteStorageEnable != nil {
		state.RemoteStorageEnable = types.BoolPointerValue(api.RemoteStorageEnable)
	}
	if api.RetentionBytes != nil {
		state.RetentionBytes = types.StringPointerValue(api.RetentionBytes)
	}
	if api.RetentionMs != nil {
		state.RetentionMs = types.StringPointerValue(api.RetentionMs)
	}
	if api.SegmentBytes != nil {
		state.SegmentBytes = types.StringPointerValue(api.SegmentBytes)
	}
	if api.SegmentIndexBytes != nil {
		state.SegmentIndexBytes = types.StringPointerValue(api.SegmentIndexBytes)
	}
	if api.SegmentJitterMs != nil {
		state.SegmentJitterMs = types.StringPointerValue(api.SegmentJitterMs)
	}
	if api.SegmentMs != nil {
		state.SegmentMs = types.StringPointerValue(api.SegmentMs)
	}
	if api.UncleanLeaderElectionEnable != nil {
		state.UncleanLeaderElectionEnable = types.BoolPointerValue(api.UncleanLeaderElectionEnable)
	}
	return state, nil
}

func flattenTag(ctx context.Context, api *apiModelTag) (*tfModelTag, diag.Diagnostics) {
	state := new(tfModelTag)
	if api.Key != nil {
		state.Key = types.StringPointerValue(api.Key)
	}
	if api.Value != nil {
		state.Value = types.StringPointerValue(api.Value)
	}
	return state, nil
}

func attrsConfig() types.ObjectType {
	return types.ObjectType{AttrTypes: map[string]attr.Type{
		"cleanup_policy":                      types.StringType,
		"compression_type":                    types.StringType,
		"delete_retention_ms":                 types.StringType,
		"diskless_enable":                     types.BoolType,
		"file_delete_delay_ms":                types.StringType,
		"flush_messages":                      types.StringType,
		"flush_ms":                            types.StringType,
		"index_interval_bytes":                types.StringType,
		"local_retention_bytes":               types.StringType,
		"local_retention_ms":                  types.StringType,
		"max_compaction_lag_ms":               types.StringType,
		"max_message_bytes":                   types.StringType,
		"message_downconversion_enable":       types.BoolType,
		"message_format_version":              types.StringType,
		"message_timestamp_after_max_ms":      types.Int64Type,
		"message_timestamp_before_max_ms":     types.Int64Type,
		"message_timestamp_difference_max_ms": types.StringType,
		"message_timestamp_type":              types.StringType,
		"min_cleanable_dirty_ratio":           types.Float64Type,
		"min_compaction_lag_ms":               types.StringType,
		"min_insync_replicas":                 types.StringType,
		"preallocate":                         types.BoolType,
		"remote_storage_enable":               types.BoolType,
		"retention_bytes":                     types.StringType,
		"retention_ms":                        types.StringType,
		"segment_bytes":                       types.StringType,
		"segment_index_bytes":                 types.StringType,
		"segment_jitter_ms":                   types.StringType,
		"segment_ms":                          types.StringType,
		"unclean_leader_election_enable":      types.BoolType,
	}}
}

func attrsTag() types.ObjectType {
	return types.ObjectType{AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	}}
}
