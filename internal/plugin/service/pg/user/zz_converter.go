// Copyright (c) 2026 Aiven, Helsinki, Finland. https://aiven.io/
// Code generated by user config generator. DO NOT EDIT.

package user

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/aiven/terraform-provider-aiven/internal/plugin/util"
)

const typeName = "aiven_pg_user"

type tfModel struct {
	ID                 types.String `tfsdk:"id"`
	AccessCert         types.String `tfsdk:"access_cert"`
	AccessKey          types.String `tfsdk:"access_key"`
	Password           types.String `tfsdk:"password"`
	PasswordWo         types.String `tfsdk:"password_wo"`
	PasswordWoVersion  types.Int64  `tfsdk:"password_wo_version"`
	PgAllowReplication types.Bool   `tfsdk:"pg_allow_replication"`
	Project            types.String `tfsdk:"project"`
	ServiceName        types.String `tfsdk:"service_name"`
	Type               types.String `tfsdk:"type"`
	Username           types.String `tfsdk:"username"`
}

func (tf *tfModel) SetID(vProject string, vServiceName string, vUsername string) {
	tf.Project = types.StringValue(vProject)
	tf.ServiceName = types.StringValue(vServiceName)
	tf.Username = types.StringValue(vUsername)
	tf.ID = types.StringValue(filepath.Join(vProject, vServiceName, vUsername))
}

type apiModel struct {
	AccessCert         *string `json:"access_cert,omitempty"`
	AccessKey          *string `json:"access_key,omitempty"`
	Password           *string `json:"password,omitempty"`
	PasswordWo         *string `json:"password_wo,omitempty"`
	PasswordWoVersion  *int64  `json:"password_wo_version,omitempty"`
	PgAllowReplication *bool   `json:"pg_allow_replication,omitempty"`
	Project            *string `json:"project,omitempty"`
	ServiceName        *string `json:"service_name,omitempty"`
	Type               *string `json:"type,omitempty"`
	Username           *string `json:"username,omitempty"`
}

// idFields the ID attribute fields, i.e.:
// terraform import aiven_pg_user.foo PROJECT/SERVICE_NAME/USERNAME
func idFields() []string {
	return []string{"project", "service_name", "username"}
}

// expandData turns TF object into Request
func expandData[R any](ctx context.Context, plan, state *tfModel, req *R, modifiers ...util.MapModifier[tfModel]) diag.Diagnostics {
	api := new(apiModel)
	if !plan.Password.IsNull() && !plan.Password.IsUnknown() {
		vPassword := plan.Password.ValueString()
		api.Password = &vPassword
	}
	if !plan.PgAllowReplication.IsNull() && !plan.PgAllowReplication.IsUnknown() {
		vPgAllowReplication := plan.PgAllowReplication.ValueBool()
		api.PgAllowReplication = &vPgAllowReplication
	}
	if !plan.Project.IsNull() || state != nil && !state.Project.IsNull() {
		vProject := plan.Project.ValueString()
		api.Project = &vProject
	}
	if !plan.ServiceName.IsNull() || state != nil && !state.ServiceName.IsNull() {
		vServiceName := plan.ServiceName.ValueString()
		api.ServiceName = &vServiceName
	}
	if !plan.Username.IsNull() || state != nil && !state.Username.IsNull() {
		vUsername := plan.Username.ValueString()
		api.Username = &vUsername
	}
	err := util.Remarshal(api, req, plan, modifiers...)
	if err != nil {
		var diags diag.Diagnostics
		diags.AddError("Remarshal error", fmt.Sprintf("Failed to remarshal dtoModel to Request: %s", err.Error()))
		return diags
	}
	return nil
}

// flattenData turns Response into TF object
func flattenData[R any](ctx context.Context, state *tfModel, rsp *R, modifiers ...util.MapModifier[tfModel]) diag.Diagnostics {
	api := new(apiModel)
	err := util.Remarshal(rsp, api, state, modifiers...)
	if err != nil {
		var diags diag.Diagnostics
		diags.AddError("Remarshal error", fmt.Sprintf("Failed to remarshal Response to dtoModel: %s", err.Error()))
		return diags
	}
	if api.AccessCert != nil || state.AccessCert.IsUnknown() {
		state.AccessCert = util.StringPointerValue(api.AccessCert)
	}
	if api.AccessKey != nil || state.AccessKey.IsUnknown() {
		state.AccessKey = util.StringPointerValue(api.AccessKey)
	}
	if api.Password != nil || state.Password.IsUnknown() {
		state.Password = util.StringPointerValue(api.Password)
	}
	if api.PgAllowReplication != nil || state.PgAllowReplication.IsUnknown() {
		state.PgAllowReplication = types.BoolPointerValue(api.PgAllowReplication)
	}
	if api.Project != nil && !state.Project.IsUnknown() {
		state.Project = util.StringPointerValue(api.Project)
	}
	if api.ServiceName != nil && !state.ServiceName.IsUnknown() {
		state.ServiceName = util.StringPointerValue(api.ServiceName)
	}
	if api.Type != nil || state.Type.IsUnknown() {
		state.Type = util.StringPointerValue(api.Type)
	}
	if api.Username != nil && !state.Username.IsUnknown() {
		state.Username = util.StringPointerValue(api.Username)
	}
	// Response may not contain ID fields.
	// In that case, `terraform import` won't be able to set them. Gets values from the ID.
	if state.ID.ValueString() != "" {
		var parts [3]string
		for i, v := range strings.SplitN(state.ID.ValueString(), "/", 3) {
			parts[i] = v
		}
		if state.Project.ValueString() == "" {
			state.Project = types.StringValue(parts[0])
		}
		if state.ServiceName.ValueString() == "" {
			state.ServiceName = types.StringValue(parts[1])
		}
		if state.Username.ValueString() == "" {
			state.Username = types.StringValue(parts[2])
		}
	}
	state.SetID(state.Project.ValueString(), state.ServiceName.ValueString(), state.Username.ValueString())
	return nil
}
