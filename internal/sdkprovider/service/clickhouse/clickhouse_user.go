package clickhouse

import (
	"context"
	"fmt"

	avngen "github.com/aiven/go-client-codegen"
	"github.com/aiven/go-client-codegen/handler/clickhouse"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/aiven/terraform-provider-aiven/internal/common"
	"github.com/aiven/terraform-provider-aiven/internal/schemautil"
	"github.com/aiven/terraform-provider-aiven/internal/schemautil/userconfig"
)

func aivenClickhouseUserSchema() map[string]*schema.Schema {
	s := map[string]*schema.Schema{
		"project":      schemautil.CommonSchemaProjectReference,
		"service_name": schemautil.CommonSchemaServiceNameReference,
		"username": {
			Type:         schema.TypeString,
			Required:     true,
			ForceNew:     true,
			ValidateFunc: schemautil.GetServiceUserValidateFunc(),
			Description:  userconfig.Desc("The name of the ClickHouse user.").ForceNew().Build(),
		},
		"uuid": {
			Type:        schema.TypeString,
			Computed:    true,
			Description: "UUID of the ClickHouse user.",
		},
		"required": {
			Type:        schema.TypeBool,
			Computed:    true,
			Description: "Indicates if a ClickHouse user is required.",
		},
	}

	return schemautil.MergeSchemas(s, schemautil.ServiceUserPasswordSchema())
}

func ResourceClickhouseUser() *schema.Resource {
	return &schema.Resource{
		Description:   "Creates and manages a ClickHouse user.",
		CreateContext: common.WithGenClient(resourceClickhouseUserCreate),
		ReadContext:   common.WithGenClient(resourceClickhouseUserRead),
		UpdateContext: common.WithGenClient(resourceClickhouseUserUpdate),
		DeleteContext: common.WithGenClient(resourceClickhouseUserDelete),
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Timeouts:      schemautil.DefaultResourceTimeouts(),
		CustomizeDiff: schemautil.CustomizeDiffServiceUserPasswordWoVersion,

		Schema: aivenClickhouseUserSchema(),
	}
}

func resourceClickhouseUserCreate(ctx context.Context, d *schema.ResourceData, client avngen.Client) error {
	projectName := d.Get("project").(string)
	serviceName := d.Get("service_name").(string)
	username := d.Get("username").(string)

	u, err := client.ServiceClickHouseUserCreate(
		ctx,
		projectName,
		serviceName,
		&clickhouse.ServiceClickHouseUserCreateIn{
			Name: username,
		},
	)
	if err != nil {
		return fmt.Errorf("cannot create ClickHouse user: %w", err)
	}

	if err = upsertClickHousePassword(ctx, d, client, projectName, serviceName, u.Uuid, u.Password); err != nil {
		return err
	}

	d.SetId(schemautil.BuildResourceID(projectName, serviceName, u.Uuid))

	return resourceClickhouseUserRead(ctx, d, client)
}

func resourceClickhouseUserRead(ctx context.Context, d *schema.ResourceData, client avngen.Client) error {
	projectName, serviceName, uuid, err := schemautil.SplitResourceID3(d.Id())
	if err != nil {
		return err
	}

	var user *clickhouse.UserOut
	ul, err := client.ServiceClickHouseUserList(ctx, projectName, serviceName)
	if err != nil {
		return err
	}

	for _, u := range ul {
		if u.Uuid == uuid {
			user = &u
			break
		}
	}

	if user == nil {
		return schemautil.ResourceReadHandleNotFound(fmt.Errorf("user %q not found", d.Id()), d)
	}

	if err = d.Set("project", projectName); err != nil {
		return err
	}
	if err = d.Set("service_name", serviceName); err != nil {
		return err
	}
	if err = d.Set("username", user.Name); err != nil {
		return err
	}
	if err = d.Set("uuid", user.Uuid); err != nil {
		return err
	}
	if err = d.Set("required", user.Required); err != nil {
		return err
	}

	return nil
}

func resourceClickhouseUserUpdate(ctx context.Context, d *schema.ResourceData, client avngen.Client) error {
	projectName, serviceName, uuid, err := schemautil.SplitResourceID3(d.Id())
	if err != nil {
		return err
	}

	if err = upsertClickHousePassword(ctx, d, client, projectName, serviceName, uuid, nil); err != nil {
		return err
	}

	return resourceClickhouseUserRead(ctx, d, client)
}

func resourceClickhouseUserDelete(ctx context.Context, d *schema.ResourceData, client avngen.Client) error {
	projectName, serviceName, uuid, err := schemautil.SplitResourceID3(d.Id())
	if err != nil {
		return err
	}

	err = client.ServiceClickHouseUserDelete(ctx, projectName, serviceName, uuid)
	if common.IsCritical(err) {
		return err
	}

	return nil
}

// upsertClickHousePassword handles password setting and rotation for ClickHouse users.
// Similar to UpsertPassword in schemautil but for ClickHouse's specific API.
func upsertClickHousePassword(
	ctx context.Context,
	d *schema.ResourceData,
	client avngen.Client,
	projectName, serviceName, uuid string,
	autoGeneratedPassword *string,
) error {
	customPassword, shouldReset := shouldResetClickHousePassword(d)

	// on create, if no custom password and we have auto-generated, store it
	if d.Id() == "" && customPassword == nil && autoGeneratedPassword != nil {
		return d.Set("password", *autoGeneratedPassword)
	}

	if !shouldReset {
		return nil
	}

	// rotate password
	newPassword, err := client.ServiceClickHousePasswordReset(
		ctx,
		projectName,
		serviceName,
		uuid,
		&clickhouse.ServiceClickHousePasswordResetIn{
			Password: customPassword,
		},
	)
	if err != nil {
		return fmt.Errorf("cannot reset ClickHouse user password: %w", err)
	}

	// handle state updates based on password
	usingWriteOnlyPassword := false
	if version, ok := d.GetOk("password_wo_version"); ok && version.(int) > 0 {
		usingWriteOnlyPassword = true
	}

	if customPassword == nil { // auto-generated password: store in state
		if err = d.Set("password", newPassword); err != nil {
			return err
		}
	} else if usingWriteOnlyPassword { // write-only password: clear the password field in state
		if err = d.Set("password", ""); err != nil {
			return err
		}
	}

	return nil
}

// shouldResetClickHousePassword determines if a password reset is needed and returns the password to use.
// Similar to shouldResetPassword in schemautil but for ClickHouse's UUID-based API.
func shouldResetClickHousePassword(d *schema.ResourceData) (customPassword *string, shouldReset bool) {
	// write-only password takes precedence
	passwordWoAttr := d.GetRawConfig().GetAttr("password_wo")
	if !passwordWoAttr.IsNull() {
		pwd := passwordWoAttr.AsString()
		customPassword = &pwd
	} else if pwd, ok := d.GetOk("password"); ok {
		p := pwd.(string)
		customPassword = &p
	}

	// reset needed on create or when any password field changes
	shouldReset = d.Id() == "" || d.HasChange("password") || d.HasChange("password_wo_version")

	return customPassword, shouldReset
}
